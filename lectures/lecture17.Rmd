---
subtitle: "DATASCI 306: Lecture 17"
title: "Date and Time"
output: 
  learnr::tutorial:
    progressive: true
    css: css/lecture.css
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(nycflights13)
```

# Dates 
Most of us have a pretty firm grasp of dates, but they can be more complicated than you might think. Consider these three questions from the book:

* Does every year have 365 days?
* Does every day have 24 hours?
* Does every minute have 60 seconds?

The answer to all three is "no."

## Date - Types

There are three different date classes in R:

* A date, printed in a tibble as `<date>`, represents a full day on the calendar.
* A time within a day, printed as `<time>`, represents a specific time within an (unspecified) day.
* A date-time is a date plus a time (tibble: `<dttm>`). A date-time uniquely identifies an instant in time (up to a given precision, usually 1 second).

There are lots of different formats, timezones, and leap years to deal with. The `lubridate` package helps:

```{r}
library(lubridate)
```


## Dates and date-times
Some useful functions:

```{r}
today()
now()
```

Weâ€™ve already seen examples of date-times in the `flights` tibble:

```{r}
select(flights, time_hour) |> print()
```

## The `mdy`, `ymd`, and `dmy` functions

Converting strings in different formats to dates and times is easy with these convenience functions:

```{r}
# Only date
mdy("10/01/2022") # Oct. 1
ymd("2022-10-01")
dmy("01.10.2022")
dmy("31-Jan-2017")
dmy("31 1 2017")

# Date and time
ymd_hms("2017-01-31 20:11:59")
mdy_hms("10/01/2022 12:01:37")
mdy_hm("01/31/2017 08:01")

```
`UTC` stands for Coordinated Universal Time. 
It is the primary time standard by which the world regulates clocks and time.
EST is in the UTC-5 time zone.


The `_hms` version will parse `HOURS:MINUTES:SECONDS`, while `_hm` will just parse `HOURS:MINUTES`. AM/PM can be included; otherwise, a 24-hour clock is assumed. 

## Setting Timezone

We can select a timezone using the nearest major city:
```{r}
mdy_hms("10/01/2022 12:01:37", tz = "America/Detroit")
mdy_hms("12/01/2022 12:01:37", tz = "America/Detroit")
```

To convert between time zones, you can use `with_tz()`:
```{r}
detroit_time <- mdy_hms("10/01/2022 12:01:37", tz = "America/Detroit")
with_tz(detroit_time, "Europe/London")
```

## Exercise

Parse the following into dates or date-times:
```{r parsed, exercise = TRUE}
dt1 <- "31/10/89"
dt2 <- c("2022-07-01 3:10am",
         "1852-01-15 7:00pm")
```


```{r parsed-solution}
dt1 <- "31/10/89"
dt2 <- c("2022-07-01 3:10am",
         "1852-01-15 7:00pm")
dmy(dt1)
ymd_hm(dt2)
```

## using `as_datetime`

Sometimes you can get away with calling `as_datetime()`:

```{r}
as_datetime("2017-01-02 20:11:59")
```

But not always:
```{r}
as_datetime("01-02-2017 20:11:59")
```

## `parse_datetime`
Another convenience function to use when `as_datetime` fails is `parse_datetime`:

```{r}
parse_datetime("22/10/1, 10:01:00", 
               format = "%y/%m/%d, %H:%M:%S")
```

>* Year: four digit `"%Y"`, two digit `"%y"`
>* Month: number `"%m"`, abbreviation `%b`, full name `%B`
>* Day: number in month `"%d"`
>* Hours:minutes:seconds: `"%H:%M:%S"`
>* See the `parse_datetime` documentation for more.

## using `make_date` and `make_datetime`

These functions can create dates from individual (numerical) components:

```{r}
make_datetime(2024, 3, 5, 10, 00, 59, tz = "EST")
make_date(2024, 01, 10)
```

## The epoch

UNIX systems sometimes represent time as "the number of seconds which have elapsed since 1-1-1970." This date is known as 'the epoch'. So you may occasionally come across date-times that look like this:

```{r}
now() |> as.integer()
```
To convert these to a date format, you can use `as_datetime`:

```{r}
as_datetime(3600 * 24)  # 24 hours after the epoch
```





## Extracting components

```{r}
right_now <- now()
day(right_now) # same as mday()
month(right_now)
year(right_now)
yday(right_now) # day within year ("Julian date")
wday(right_now) # day within week, starting with Sunday
hour(right_now)
minute(right_now)
second(right_now)
```

## Time Math 

```{r}
ymd("2023/01/04") - mdy("12/16/2022")
```

The result is a `difftime` object, which represents a time difference.

The `seconds`, `minutes`, `hours`, `days`, and `weeks` functions can be used to get offsets:
```{r}
right_now <- now()
right_now
right_now + minutes(10)
right_now + weeks(7)
```

## Time spans

After doing math, you might want to convert the units:

```{r}
# Days to the last day of class!
semester_end <- dmy_hms("10122025 23:59:59") - now()
# A `difftime` object is returned.

sed <- as.duration(semester_end)

as.integer(sed, "days")
as.numeric(sed, "minutes")

```
You can use the `update` function to update a specific part of the date:

```{r}
(d = today() - update(today(), day = 26))
```

## Durations
There are equivalent `d*` functions (`dyears`, etc.) for constructing durations directly.

Any time part can be converted to seconds using the duration class:

```{r}
as.duration(1234)
dseconds(10)
dweeks(3)
```


## Arithmetic with duration

Arithmetic with durations works as you would expect.

```{r}

2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

You have to be careful when adding durations and dates. What is one day after March 8, 2025, at 1:00 p.m.?

```{r}
# But what happened to this addition?
march8 = mdy_hm("March. 8, 2025 13:00PM", tz="America/Detroit")
march8 + ddays(1)

# this seems fine
march9 = mdy_hm("March. 9, 2025 13:00PM", tz="America/Detroit")
march9 + ddays(1)
```

You can use period methods from `lubridate` instead:

```{r}
march8 = mdy_hm("March. 8, 2025 13:00PM", tz="America/Detroit")
march8 + days(1)

```
## Exercise

Parse these dates.

* What is the range of the dates? 
* What is the mean date?
* What is the median date? 
* Suppose you want reminders for the anniversary of these dates in the coming year, one month in advance. Find the dates for the reminders.

```{r diffex, exercise = TRUE}
ds <- c("1981-09-25", "1982-03-06", "2010-12-14", "2012-10-18", "2019-04-03")
```

```{r diffex-solution}
ds <- c("1981-09-25", "1982-03-06", "2010-12-14", "2012-10-18", "2019-04-03")

# parse as year-month-day format
ds_parsed <- ymd(ds)

# range
range(ds_parsed)
# or
min(ds_parsed)
max(ds_parsed)

# mean and median
mean(ds_parsed)
median(ds_parsed)

# setting reminders
## method 1
year_diff <- year(today()) - year(ds_parsed)
ds_this_year <- ds_parsed + years(year_diff) - months(1)
if_else(ds_this_year < today(), ds_this_year + years(1), ds_this_year) 

## method 2
ds_parsed_2 <- ds_parsed - months(1)
year(ds_parsed_2) <- year(today())
ds_parsed_2 + if_else(ds_parsed_2 < today(), years(1),  years(0))
```



## Revisiting Some Common Operations on Date Columns

```{r}
aatemp <- read_csv("data/ann_arbor_weather.csv.gz")
aatemp |> select(DATE) |> head(3)


## Finding the maximum TMAX per year-month: 
aatemp |> group_by(year(DATE), month(DATE)) |> 
  summarize(m = max(TMAX, na.rm = TRUE)) |> 
  arrange(desc(m)) |> head(5)

## Limiting to a specific date range:
aatemp |> filter(DATE >= "2018-01-01", DATE <= "2018-03-31") |>
  nrow() # 31 + 28 + 31
```

## Exercise

Using the `weather` table in the `nycflights13` package, compute the average temperature at each airport (`origin`) between 9:00 a.m. and 3:00 p.m. on September 1, 2013 (see the `time_hour` column).

```{r nyc0901temp, exercise = TRUE}

```


```{r nyc0901temp-solution}

filter(weather, time_hour >= "2013-09-01 09:00:00", time_hour <= "2013-09-01 17:00:00") |>
  group_by(origin) |> summarize(mean(temp))
```

## Exercise

The `nycflights13` table has scheduled as well as actual arrival and departure times. Let's create a date-time variable from the actual departure times.

First, we need to take note of the fact that `dep_time` and `arr_time` are in a strange format:

```{r}
flights |> select(dep_time, sched_dep_time, arr_time, sched_arr_time, year, month, day) |> head()
```

Now, convert the values to `dttm`.

```{r nycdate, exercise = TRUE}

```

```{r nycdate-solution}
flights_dt <- flights |>
  mutate(across(c(dep_time, sched_dep_time, arr_time, sched_arr_time), ~ make_datetime(year, month, day, . %/% 100, . %% 100)))
```
## Analysis

Now we can use built-in R commands to query and plot these data based on the actual departure times:

```{r}

flights_dt <- flights |>
  mutate(across(c(dep_time, sched_dep_time, arr_time, sched_arr_time), ~ make_datetime(year, month, day, . %/% 100, . %% 100)))

flights_dt |>
  filter(dep_time < ymd(20130130), dep_time >= ymd(20130120)) |>
  ggplot(aes(x = dep_time)) +
  geom_density(bw = 3*3600) # bw is the bandwidth, here 3 hours
```

**Histogram**

Let's also plot a histogram: 

```{r}
flights_dt |>
  filter(dep_time < ymd(20130130), dep_time >= ymd(20130120)) |>
  ggplot(aes(x = dep_time)) +
  geom_histogram()
```

Notice that this command and the resulting graph look much nicer than if we did not use the date classes:

* The filter on `dep_time` looks more natural than `filter(day < 2, month == 1, year == 2013)`.
* We can easily express the bin width of 600 seconds in `geom_freqpoly(binwidth = 600)`. When you use date-times in a numeric context (like in a histogram), 1 means 1 second; for dates, 1 means 1 day.
* The plot's x-axis has nice, readable labels.

## More analysis

By extracting the minute component of the scheduled departure time, we uncover a surprising pattern:

```{r}
flights_dt |>
  mutate(minute = minute(dep_time)) |>
  group_by(minute) |>
  summarise(
    avg_delay = mean(dep_delay, na.rm = TRUE)) |>
  ggplot(aes(minute, avg_delay)) +
    geom_line() + labs(x="minute(dep_time)")
```

But when grouped by scheduled departure time, the delays seem to be random:

```{r}
sched_dep <- flights_dt |>
  mutate(minute = minute(sched_dep_time)) |>
  group_by(minute) |>
  summarise(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n())

ggplot(sched_dep, aes(minute, avg_delay)) +
  geom_line()
     
```

## Summary

In this lecture, we covered the basics of working with strings and dates in R.

Key `stringr` functions:
* `str_c()`: to combine strings.
* `str_length()`: to get the length of strings.
* `str_sub()`: to extract or modify substrings.
* `str_split()`: to split strings into pieces.
* `str_count()`: to count occurrences of a pattern.
* `str_starts()`: to check if a string starts with a pattern.

Key `lubridate` functions:
* `today()`, `now()`: to get the current date and time.
* `ymd()`, `mdy()`, `dmy()` and their `_hms` variants: to parse strings into dates and times.
* `year()`, `month()`, `day()`, `hour()`, `minute()`, `second()`: to extract components from dates and times.
* `duration` and `period` functions (e.g., `ddays()`, `days()`): for robust arithmetic with dates.




