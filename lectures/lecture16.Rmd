---
subtitle: "DATASCI 306: Lecture 16"
title: "Regex"
output: 
  learnr::tutorial:
    progressive: true
    css: css/lecture.css
runtime: shiny_prerendered
---


```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
set.seed(2939394)
library(harrypotter)
ch1 <- philosophers_stone[[1]]
```

## Today's lecture
* Understand basic regular expressions.
* Use regular expressions to extract data from text.

These notes correspond to Chapter 16 of your book.



## Raw strings
Sometimes, adding the escape sequence to escape a series of special characters can become very confusing. Let's understand this with an example:

```{r}
tricky <- "double_quote <- \"\\\"\" # or '\"' single_quote <- '\\\'' # or \"'\""

cat(tricky)
```

Gosh, too many escape sequences make it confusing!

Instead, let's construct `raw` strings using `r`: 

```{r}
simple <- r"(double_quote <- "\"" # or '"' single_quote <- '\'' # or "'")"
cat(simple)
```

Using `r` essentially tells R: "Take the text inside these delimiters exactly as you see it. Do not interpret any character as special."

## Regular expressions

Regular expressions (regex, regexps) are a programming language that allows you to describe patterns in strings. They have a steep learning curve but are very powerful for working with text data. In this class, we will just focus on the basics of regexps. A good tool for learning regexps is [regex101](https://regex101.com/), which lets you interactively edit and debug your regular expressions.

>* Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.

>* â€” Jamie Zawinski (famous nerd)

In these slides, we will use the command `str_view` to understand how regular expressions work.

## Simple regex

The most basic regular expression is a plain string. It will match if the other string contains it as a substring.

```{r}
x = c("apple", "banana", "pear") |> print()
str_view(x, pattern = "an")
```

Here, `str_view` has matched our regexp ("`an`") inside of the second string, `banana`, of the vector `x`.

Let's look at the `fruit` vector:

```{r}
fruit |> print()
```

Let's find all the fruits that have `berry` in their name:

```{r}
str_view(fruit, 'berry')
```

## Using Wildcards

Our first non-trivial regular expression will use a wildcard: `.`. Used inside of a regular expression, the period matches any single character:

```{r}
str_view("else every eele etcetera", "e..e ")
```

If we want to "extract" the first match, we can use `str_extract()` instead:

```{r}
str_extract("else every eele etcetera", "e..e ")
```

What about all the matches? You can probably guess the function for that:

```{r}
str_extract_all("else every eele etcetera", "e..e")
```

## Exercise

What is the first string in Chapter 1 of *Philosopher's Stone* that matches a pattern starting with 'H', followed by any three characters, and ending with 'y'?

```{r regex_1, exercise = TRUE}
ch1
```

```{r regex_1-solution}
str_extract(ch1, 'H...y')
```

## Character classes

Instead of matching anything using `.`, we often want to match a class of characters: letters, numbers, spaces, etc. A "character class" is a special pattern that matches a collection of characters. There are four built-in character classes you should know:

* `\w`: matches any alphanumeric character and is equivalent to using `[A-Za-z0-9_]`.
* `\s`: matches single space, tab, and newline characters and is equivalent to using `[\t\n\r\f\v]`.
* `\d`: matches any digit and is equivalent to using `[0-9]`.
* `\b`: matches a "word boundary" (more on this in a moment).

`\w` matches any word character:

```{r}
str_view("this is a word", "\\w")
```

Note the additional level of escaping needed here.



If you have a missing backslash, then...

```{r missing-backslash, exercise = TRUE}
str_view("this is a word", "\w")
```


**Raw representation**

```{r}
str_view("this is a word", r"(\w)")
```

**`\d` matches any digit**

```{r}
str_view(c("number1", "two", "3hree"), "\\d")
```

**`\s` will match whitespace (spaces, tabs, and newlines)**

```{r}
y = c("spa ce", "hello\tworld", "multi\nline")
writeLines(y)
str_view(y, "\\s")
```

## Using the `[]` expression

You can also create your own character class using square brackets: `[abc]` will match `a`, `b`, or `c`. In other words, the 'width' of a character class is one character by default.

```{r}
str_view(fruit, '[be]a')  # Match either 'b' or 'e' followed by 'a'
```

We can use character classes to match the first capital letter of a capitalized word:

```{r}
str_view(c("These", "are", "some Capitalized words"),
         "[ABCDEFGHIJKLMNOPQRSTUVWXYZ]")
```

We don't need to go to all the trouble of typing each capital letter. We can use the shortcut `[A-Z]` instead.

```{r}
str_view(c("These", "are", "some Capitalized words"), "[a-e]")
```

## Word boundaries

A final character class we'll use frequently is `\b`, which stands for "word boundary." A word boundary matches the "edges" of a word:

```{r}
str_view(c("Rafael Nadal", "Roger Federer", "Novak Djokovic"), "\\b")
```
Every word has a word boundary on either side, so we can use this in combination with other character classes to match certain kinds of words in text.

## Exercise
About how many words start with 'H' in Chapter 1? Explore using `str_count`

```{r starts_with, exercise = TRUE}

```

```{r starts_with-solution}
ch1 |> str_count('\\bH\\w')
```


In this exercise, we matched the pattern

`<word boundary><character H><any number of word characters (*)>`


## Quantifiers

How many words are there in Chapter 1? 
We can use `\\w+` to find words. 

```{r}
str_count(ch1, "\\w+")
```

Now, let's understand this expression in detail:

`\\w+ - <any number of word characters appearing together>`
The four quantifiers you should know are:

* `?`: matches zero or one of the preceding characters.
* `+`: matches one or more of the preceding characters.
* `*`: matches zero or more of the preceding characters.
* `{x}`: matches exactly `x` of the preceding characters.
* `{x,y}`: matches between `x` and `y` of the preceding characters.
* `{x,}`: matches at least `x` of the preceding characters.

So, to count the number of words using the pattern shown above:

```{r}
# get all words that are between 10 and 22 characters long
str_extract_all(ch1, '\\w{10,22}\\b')
```

## Exercise


How many words in Chapter 1 match the pattern:

`<word boundary><lowercase 'h'><exactly 5 characters><word boundary>`



```{r five-characters, exercise = TRUE}

```

```{r five-characters-solution}
str_count(ch1, '\\bh\\w{5}\\b')
```


## Negations
Earlier, we looked at quotations. The first quotation in Chapter 1 is:

```{r}
str_sub(ch1, 2150, 2163)
```

How can we find other quotes? The pattern for a quote is a quotation mark, followed by any number of characters that are not a quotation mark, followed by another quotation mark:

`<quotation mark><anything that is not a quotation mark><quotation mark>`

To match this, we will use a negation. A negation is a character class that begins with the character `^`. It matches anything that is not inside the character class:

```{r}
str_view("match doesn't match", "[^aeiou]+")
```

To match a quotation, we'll input the pattern that we specified above:


```{r}
str_view('"Here is a quotation", said the professor. "And here is another."', '"[^"]+"')
```

## Exercise

Find all the character names in Harry Potter that are in the middle of a sentence. 


Our pattern becomes:

`<one or more spaces><capital letter><at least five lowercase letters><not ending in a period>`

```{r proper-names, exercise = TRUE}

```

```{r proper-names-solution}
str_extract_all(ch1, '\\s+[A-Z][a-z]{5,}[^.]') |> table()
```


## Grouping

"Professor" is one of the most common capitalized words in this book. Is there a character named Professor, or is it just a title? Now, let's try to match one or more capitalized words in a row. We can accomplish this by creating a group and then applying a quantifier to it.

To create a group, I surround a part of my regexp with parentheses:

```{r}
str_view("this will be grouped", "([a-z]+ ?)+")
```

The parentheses do not change the regular expression (but they are doing something else, which we will discuss shortly). But now I can apply a quantifier to the whole group.


So now we take the previous pattern and group it:

`(<capital letter><at least five lowercase letters><space>){match 1+ times}`

```{r}
str_extract_all(ch1, '([A-Z][a-z]{5,} ?)+') |> table()
```

Let's check one of them. The text contains "Bonfire Night":

```{r}
str_locate(ch1, 'Bonfire')

str_sub(ch1, 8957, 8957 + 20)
```

Why isn't `Night` included in the match? The pattern `[A-Z][a-z]{5,}` requires at least five lowercase letters after the capital letter. "Night" only has four ("ight"), so it doesn't match that part of the pattern.

## Backreferences
Parentheses define groups that can be referred to later in the match as `\1`, `\2`, etc. This is called a backreference. 

For example:

`(.)\1`

will match the same character repeated twice in a row:

```{r}
"eyxyel"  |> str_view("(.)x\\1")
```

## Anchors

Sometimes we want a match to occur at a particular position in the string. For example, "all words which start with 'b'". For this, we have the special anchor characters: `^` and `$` matches the end.

```{r}
x <- c('apple', 'banana', 'pear')
str_view(x, '^b')
str_view(x, 'r$')
```

## `str_match` function

`str_match(v, re)` will create a matrix out of the grouped matches in `re`. The first column has the whole match, and additional columns are added for each character group. If the pattern does not match, you will get `NA`s.

```{r}
head(str_match(words, '(.).*(.)'))
```

## `str_replace` function
`str_replace(v, re, rep)` will replace each match of `re` in `v` with `rep`. The most basic usage is as a sort of "find and replace":

```{r}
str_replace('Give me liberty or give me death', '\\w+', 'pizza')
```