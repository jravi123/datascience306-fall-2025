---
subtitle: "DATASCI 306: Lecture 15"
title: "Strings and Text Data"
output: 
  learnr::tutorial:
    progressive: true
    css: css/lecture.css
runtime: shiny_prerendered
---


```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(nycflights13)
set.seed(2939394)
library(remotes)
# remotes::install_github("bradleyboehmke/harrypotter")
library(harrypotter)
```

## Today's lecture

* Understand the basics of working with strings in R.
* Convert data to strings.
* Extract data from strings.

These notes correspond to Chapters 14 and 17 of your book.

## String basics

A string (or "character vector" in R) is character data enclosed in double (`"`) or single (`'`) quotes.

To include quotation marks inside, we need to **escape** them:
```{r}
mle <- "\"MLE\" stands for \"Maximum Likelihood Estimate\""
mle
cat(mle) # prints directly instead of displaying as an escaped string
```

What's another way you could fix this?

```{r}
# another way of getting around this issue
'"MLE" stands for "Maximum Likelihood Estimate"'
```

## Other special characters

Since `\` is used to escape characters, if you need a literal backslash, use `\\`. 

Example:

Newline: `\n` - use `\\n` to escape the backslash if you want `\n` to be part of the string.

```{r}
cat('first line \n second line')

cat('first line \\n not second line')
```

##  `writeLines` function

We see that the `print` statement doesn't quite display the newline on the console:

```{r}
print('abc \n abc')
```

However, using the `cat` function gets us the newline:

```{r}
cat('abc \nabc')
```

We can also use `writeLines` to get around this issue:

```{r}
writeLines('abc \tabc')
```

## ASCII and Unicode

Early computers could only read and write the ASCII character setâ€”essentially just Roman letters, numbers, and some punctuation.

Nowadays, computers need to be able to understand alphabets from all over the world. For this, we have Unicode.

You can print characters if you know their Unicode using `\u`. For example, the copyright character has the Unicode `00A9`. Wikipedia has a [complete list](https://en.wikipedia.org/wiki/List_of_Unicode_characters).

```{r}
print("\u00A9")
```

## String functions in R
Through the `stringr` package, `tidyverse` has many useful functions for combining strings.

## Combining strings

If we need to make strings out of other strings, we have two (more or less identical) functions:

* Old school: `paste` (joins with " ") and `paste0` (joins with "");
* New school: `str_c` (joins with ""); used in our book.

```{r}
paste('a','b','c')

paste("Section", c("200", "100", "200"), 
      "meets on", 
      c("Tuesday", "Monday", "Wednesday"))
```
The same function using `str_c`:


```{r}
str_c('a','b','c')

str_c("Section", c("100", "200", "100"), 
      "meets on", 
      c("Tuesday", "Monday", "Wednesday"))
```
To separate the strings, use the `sep` keyword argument:

```{r}
str_c('a','b','c', sep = ", ")

str_c("Section", c("100", "200", "100"), 
      "meets on", 
      c("Tuesday", "Monday", "Wednesday"), sep = " ")

```

## Exercise

Join the following using newline characters. Demonstrate using `str_c`.

```{r sonnet18, exercise = TRUE}
line1 <- "Nor shall death brag thou wander'st in his shade,"
line2 <- "When in eternal lines to time thou grow'st:"
line3 <- "So long as men can breathe or eyes can see,"
line4 <- "So long lives this, and this gives life to thee."
```

```{r sonnet18-solution}
line1 <- "Nor shall death brag thou wander'st in his shade,"
line2 <- "When in eternal lines to time thou grow'st:"
line3 <- "So long as men can breathe or eyes can see,"
line4 <- "So long lives this, and this gives life to thee."
cat(str_c(line1, line2, line3, line4, sep = '\n'))
```


## Properties of strings

```{r, echo = FALSE}
line1 <- "Nor shall death brag thou wander'st in his shade,"
line2 <- "When in eternal lines to time thou grow'st:"
line3 <- "So long as men can breathe or eyes can see,"
line4 <- "So long lives this, and this gives life to thee."
```

The `length` function in R tells you how many items are in a vector:

```{r}
sonnet18_end <- c(line1, line2, line3, line4)
length(sonnet18_end)
```

To find the length of the strings in terms of characters, use `str_length`:
```{r}
str_length(sonnet18_end) # base::nchar also works
```

## Flattening strings

`str_flatten` takes a vector of strings and flattens them into one string.

```{r}
# list all the air carriers flying out of each airport
distinct(flights, origin, carrier)
distinct(flights, origin, carrier) |>
  group_by(origin) |>
    summarize(carrier = str_flatten(carrier, ", "))
```



## Subsetting

The `str_sub` function can retrieve or change **substrings**.

```{r}
line1
str_sub(line1, 11, 20)
line2
str_sub(line2, 36)
str_sub(line2, -8)
line4
line4b <- line4
str_sub(line4b, 1, 10) <- "REMOVED"
line4b
```

Using a negative number for the start or end position will count from the end of the string. For example, `str_sub(line2, -8)` extracts the last 8 characters of `line2`.




## `str_split` Function


  The `str_split` function is used to break a single string into multiple smaller strings. It does this by looking for a specific character or pattern (called a "delimiter") and splitting the original string wherever it finds that pattern.

  Key Arguments:

>  `string`: The string you want to split.
> `pattern`: The delimiter you want to split by. This is the character or sequence of characters that separates the pieces of the string.


Here's the full sonnet as a single string:
```{r}
sonnet18 <- "Shall I compare thee to a summer's day?\nThou art more lovely and more temperate:\nRough winds do shake the darling buds of May,\nAnd summer's lease hath all too short a date;\nSometime too hot the eye of heaven shines,\nAnd often is his gold complexion dimm'd;\nAnd every fair from fair sometime declines,\nBy chance or nature's changing course untrimm'd;\nBut thy eternal summer shall not fade,\nNor lose possession of that fair thou ow'st;\nNor shall death brag thou wander'st in his shade,\nWhen in eternal lines to time thou grow'st:\n\tSo long as men can breathe or eyes can see,\n\tSo long lives this, and this gives life to thee."
```

Let's split that into individual lines as strings in a vector:

```{r}
sonnet18_lines <- str_split(sonnet18, "\n") # notice use of new line
sonnet18_lines
```


## `unlist` function

`unlist` takes a list (or a vector of lists) as input and converts it into a vector. It essentially flattens the list structure, removing any nested lists and combining all elements into a single vector.

Let's take a simple character vector to understand the `unlist` function: 

```{r}

x <- list('abc','xyz')
x[1]
x[[1]]

z <- unlist(x)
z[1]
```


## Exercise

**Tokenization** is the process many computer languages use to turn strings into discrete words (or "tokens"). Use `str_split` to turn `sonnet18` into individual words. Use `unlist` on the result and answer the question: how many words are there?

```{r tokenize1, exercise = TRUE}
sonnet18 <- "Shall I compare thee to a summer's day?\nThou art more lovely and more temperate:\nRough winds do shake the darling buds of May,\nAnd summer's lease hath all too short a date;\nSometime too hot the eye of heaven shines,\nAnd often is his gold complexion dimm'd;\nAnd every fair from fair sometime declines,\nBy chance or nature's changing course untrimm'd;\nBut thy eternal summer shall not fade,\nNor lose possession of that fair thou ow'st;\nNor shall death brag thou wander'st in his shade,\nWhen in eternal lines to time thou grow'st:\n\tSo long as men can breathe or eyes can see,\n\tSo long lives this, and this gives life to thee."
```

```{r tokenize1-solution}
str_split(sonnet18, " ") |> unlist() |> length()
```

## separate_ functions
`tidyverse` has some built-in functions designed to break apart and combine string data.

* `separate_longer_delim`, `separate_longer_position`: combine multiple columns of string data into one.
* `separate_wider_delim`, `separate_wider_position`: extract string data into multiple columns. These functions work analogously to `pivot_{wider,longer}`.

`separate_wider_delim` converts a delimited string into multiple columns of data. `separate_wider_position` does the same, but it uses a fixed position.


```{r}

df <- tibble(x = c("a10.1.2022", "b10.2.2011", "e15.1.2015"))
df |>  separate_wider_delim(
    x,
    delim = ".",
    names = c("code", "edition", "year")
  )
```

Here is an example of `separate_wider_position`:
```{r}
df <- tibble(x = c("a102022", "b102011", "e152015"))
df |> separate_wider_position(
  x,
  widths = c(code = 1, edition = 2, year = 4)
)
```

## Harry Potter

Let's practice some string analysis by looking at the text of Harry Potter:

<img src = 'images/harry-potter.jpeg' />

`philosophers_stone` is a list containing 17 entries: one for each chapter of "Harry Potter and the Sorcerer's Stone" (titled differently in the U.K.). This object is created in the initialization block of this page.

Instead of reading Harry Potter, we will analyze it as a dataset.

Each entry of `philosophers_stone` is a string. There is one string per chapter, so they are quite long. 


```{r}
ch1 <- philosophers_stone[[1]]
length(philosophers_stone)
ch1
```

## Exercise
What is the longest chapter (in number of characters) in *Philosopher's Stone*?

```{r longest-chapter, exercise = TRUE}
philosophers_stone
```

```{r longest-chapter-solution}
which.max(str_length(philosophers_stone))
```

## `str_count`

Use this function to count the number of times a `pattern` is found within a string:

```{r}
# How many times does 'Harry' occur in Chapter 1?
str_count(ch1, 'Harry')
```

## `str_locate`

returns the start and end position of the first match. `str_locate_all()` returns the start and end position of *each* match.

```{r}
str_locate(ch1, 'Harry')
```

Let's verify:

```{r}
str_sub(ch1, 5243, 5247)
```

## Exercise
What are the last 100 characters of Chapter 1?

```{r last1-100, exercise=TRUE}
ch1 <- philosophers_stone[[1]]
```

```{r last1-100-solution}
ch1 |> str_sub(length(ch1)-101) 
# another way
ch1 |> str_sub(-100)
```

## Exercise
What is the last sentence of Chapter 1? 
Hint: `str_split` might be useful. Since a period `.` is a special character, you have to use the expression `\\.` to use it in functions. We'll cover more on this in the next class.

```{r last-sentence, exercise = TRUE}

```

```{r last-sentence-solution}
ch1 <- philosophers_stone[[1]]
ch1 |> str_split("\\.") |> unlist() -> sentences 
last_sentence_body <- tail(sentences, 1)
last_sentence_body
```

## Exercise
Which chapter starts with the words `THE POTIONS MASTER`?

```{r starts-with, exercise = TRUE}

```

```{r starts-with-solution}
str_starts(philosophers_stone, 'THE POTIONS MASTER')
```


## Converting the list to a tibble

We may sometimes find it useful to convert the list to a tibble and then apply `tidyverse` functions. Here is the previous solution using a tibble:


```{r}
df <- tibble(philosophers_stone)
df |> mutate(starts_with = str_starts(philosophers_stone, 'THE POTIONS MASTER')) |> select(starts_with) |> print()
```

## Exercise

Create a bar chart showing how many times the name "Harry" appears in each chapter.

```{r harry-plot, exercise = TRUE}

```

```{r harry-plot-solution}
tibble(chapter = 1:length(philosophers_stone),
       text = philosophers_stone) |>
  mutate(harry_mentions = str_count(text, "Harry")) |>
  ggplot(aes(x = chapter, y = harry_mentions)) +
  geom_col() +
  labs(title = "Frequency of 'Harry' in Each Chapter",
       x = "Chapter",
       y = "Number of Mentions")
```


